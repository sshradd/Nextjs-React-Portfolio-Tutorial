"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/schedule-meeting/page",{

/***/ "(app-pages-browser)/./src/lib/googleCalendar.ts":
/*!***********************************!*\
  !*** ./src/lib/googleCalendar.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GoogleCalendarAPI: () => (/* binding */ GoogleCalendarAPI),\n/* harmony export */   formatDateTime: () => (/* binding */ formatDateTime)\n/* harmony export */ });\n// lib/googleCalendar.ts\n// Extend Window interface for Google API\nclass GoogleCalendarAPI {\n    async initializeGapi() {\n        if (this.isInitialized) return true;\n        return new Promise((resolve, reject)=>{\n            if (false) {}\n            // Check if gapi is already loaded\n            if (window.gapi) {\n                this.loadGapiClient().then(()=>{\n                    this.isInitialized = true;\n                    resolve(true);\n                }).catch(reject);\n                return;\n            }\n            // Load gapi script\n            const script = document.createElement('script');\n            script.src = 'https://apis.google.com/js/api.js';\n            script.onload = ()=>{\n                this.loadGapiClient().then(()=>{\n                    this.isInitialized = true;\n                    resolve(true);\n                }).catch(reject);\n            };\n            script.onerror = ()=>reject(new Error('Failed to load Google API script'));\n            document.head.appendChild(script);\n        });\n    }\n    async loadGapiClient() {\n        return new Promise((resolve, reject)=>{\n            window.gapi.load('client:auth2', {\n                callback: async ()=>{\n                    try {\n                        await window.gapi.client.init({\n                            clientId: this.clientId,\n                            discoveryDocs: [\n                                'https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest'\n                            ],\n                            scope: 'https://www.googleapis.com/auth/calendar.events'\n                        });\n                        this.gapi = window.gapi;\n                        resolve();\n                    } catch (error) {\n                        reject(error);\n                    }\n                },\n                onerror: ()=>reject(new Error('Failed to load gapi client'))\n            });\n        });\n    }\n    async signIn() {\n        if (!this.gapi) {\n            throw new Error('Google API not initialized');\n        }\n        const authInstance = this.gapi.auth2.getAuthInstance();\n        if (!authInstance) {\n            throw new Error('Auth instance not available');\n        }\n        return await authInstance.signIn();\n    }\n    async createEvent(eventDetails) {\n        if (!this.gapi) {\n            throw new Error('Google API not initialized');\n        }\n        try {\n            const response = await this.gapi.client.calendar.events.insert({\n                calendarId: 'primary',\n                resource: eventDetails\n            });\n            return response.result;\n        } catch (error) {\n            console.error('Error creating calendar event:', error);\n            throw error;\n        }\n    }\n    isSignedIn() {\n        if (!this.gapi) return false;\n        const authInstance = this.gapi.auth2.getAuthInstance();\n        return authInstance && authInstance.isSignedIn.get();\n    }\n    constructor(){\n        this.isInitialized = false;\n        this.clientId = \"923849660731-834la2ph5c9lcq7kteq3p82j59e5i92p.apps.googleusercontent.com\" || 0;\n    }\n}\n// Utility function to format date/time for Google Calendar\nfunction formatDateTime(date, time) {\n    let duration = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 30;\n    const [hour, minute] = time.replace(/[AP]M/, '').trim().split(':');\n    const isPM = time.includes('PM');\n    let hour24 = parseInt(hour);\n    if (isPM && hour24 !== 12) hour24 += 12;\n    if (!isPM && hour24 === 12) hour24 = 0;\n    const startDate = new Date(date);\n    startDate.setHours(hour24, parseInt(minute), 0, 0);\n    const endDate = new Date(startDate);\n    endDate.setMinutes(endDate.getMinutes() + duration);\n    return {\n        start: startDate.toISOString(),\n        end: endDate.toISOString()\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZ29vZ2xlQ2FsZW5kYXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSx3QkFBd0I7QUFFeEIseUNBQXlDO0FBcUJsQyxNQUFNQTtJQVNYLE1BQU1DLGlCQUFtQztRQUN2QyxJQUFJLElBQUksQ0FBQ0MsYUFBYSxFQUFFLE9BQU87UUFFL0IsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1lBQzNCLElBQUksS0FBNkIsRUFBRSxFQUdsQztZQUVELGtDQUFrQztZQUNsQyxJQUFJRSxPQUFPQyxJQUFJLEVBQUU7Z0JBQ2YsSUFBSSxDQUFDQyxjQUFjLEdBQUdDLElBQUksQ0FBQztvQkFDekIsSUFBSSxDQUFDUixhQUFhLEdBQUc7b0JBQ3JCRSxRQUFRO2dCQUNWLEdBQUdPLEtBQUssQ0FBQ047Z0JBQ1Q7WUFDRjtZQUVBLG1CQUFtQjtZQUNuQixNQUFNTyxTQUFTQyxTQUFTQyxhQUFhLENBQUM7WUFDdENGLE9BQU9HLEdBQUcsR0FBRztZQUNiSCxPQUFPSSxNQUFNLEdBQUc7Z0JBQ2QsSUFBSSxDQUFDUCxjQUFjLEdBQUdDLElBQUksQ0FBQztvQkFDekIsSUFBSSxDQUFDUixhQUFhLEdBQUc7b0JBQ3JCRSxRQUFRO2dCQUNWLEdBQUdPLEtBQUssQ0FBQ047WUFDWDtZQUNBTyxPQUFPSyxPQUFPLEdBQUcsSUFBTVosT0FBTyxJQUFJQyxNQUFNO1lBQ3hDTyxTQUFTSyxJQUFJLENBQUNDLFdBQVcsQ0FBQ1A7UUFDNUI7SUFDRjtJQUVBLE1BQWNILGlCQUFnQztRQUM1QyxPQUFPLElBQUlOLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDM0JFLE9BQU9DLElBQUksQ0FBQ1ksSUFBSSxDQUFDLGdCQUFnQjtnQkFDL0JDLFVBQVU7b0JBQ1IsSUFBSTt3QkFDRixNQUFNZCxPQUFPQyxJQUFJLENBQUNjLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDOzRCQUM1QkMsVUFBVSxJQUFJLENBQUNBLFFBQVE7NEJBQ3ZCQyxlQUFlO2dDQUFDOzZCQUFnRTs0QkFDaEZDLE9BQU87d0JBQ1Q7d0JBQ0EsSUFBSSxDQUFDbEIsSUFBSSxHQUFHRCxPQUFPQyxJQUFJO3dCQUN2Qko7b0JBQ0YsRUFBRSxPQUFPdUIsT0FBTzt3QkFDZHRCLE9BQU9zQjtvQkFDVDtnQkFDRjtnQkFDQVYsU0FBUyxJQUFNWixPQUFPLElBQUlDLE1BQU07WUFDbEM7UUFDRjtJQUNGO0lBRUEsTUFBTXNCLFNBQXVCO1FBQzNCLElBQUksQ0FBQyxJQUFJLENBQUNwQixJQUFJLEVBQUU7WUFDZCxNQUFNLElBQUlGLE1BQU07UUFDbEI7UUFFQSxNQUFNdUIsZUFBZSxJQUFJLENBQUNyQixJQUFJLENBQUNzQixLQUFLLENBQUNDLGVBQWU7UUFDcEQsSUFBSSxDQUFDRixjQUFjO1lBQ2pCLE1BQU0sSUFBSXZCLE1BQU07UUFDbEI7UUFFQSxPQUFPLE1BQU11QixhQUFhRCxNQUFNO0lBQ2xDO0lBRUEsTUFBTUksWUFBWUMsWUFBMkIsRUFBZ0I7UUFDM0QsSUFBSSxDQUFDLElBQUksQ0FBQ3pCLElBQUksRUFBRTtZQUNkLE1BQU0sSUFBSUYsTUFBTTtRQUNsQjtRQUVBLElBQUk7WUFDRixNQUFNNEIsV0FBVyxNQUFNLElBQUksQ0FBQzFCLElBQUksQ0FBQ2MsTUFBTSxDQUFDYSxRQUFRLENBQUNDLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDO2dCQUM3REMsWUFBWTtnQkFDWkMsVUFBVU47WUFDWjtZQUNBLE9BQU9DLFNBQVNNLE1BQU07UUFDeEIsRUFBRSxPQUFPYixPQUFPO1lBQ2RjLFFBQVFkLEtBQUssQ0FBQyxrQ0FBa0NBO1lBQ2hELE1BQU1BO1FBQ1I7SUFDRjtJQUVBZSxhQUFzQjtRQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDbEMsSUFBSSxFQUFFLE9BQU87UUFDdkIsTUFBTXFCLGVBQWUsSUFBSSxDQUFDckIsSUFBSSxDQUFDc0IsS0FBSyxDQUFDQyxlQUFlO1FBQ3BELE9BQU9GLGdCQUFnQkEsYUFBYWEsVUFBVSxDQUFDQyxHQUFHO0lBQ3BEO0lBM0ZBLGFBQWM7YUFGTnpDLGdCQUF5QjtRQUcvQixJQUFJLENBQUNzQixRQUFRLEdBQUdvQiwwRUFBd0MsSUFBSSxDQUFFO0lBQ2hFO0FBMEZGO0FBRUEsMkRBQTJEO0FBQ3BELFNBQVNHLGVBQWVDLElBQVksRUFBRUMsSUFBWTtRQUFFQyxXQUFBQSxpRUFBbUI7SUFDNUUsTUFBTSxDQUFDQyxNQUFNQyxPQUFPLEdBQUdILEtBQUtJLE9BQU8sQ0FBQyxTQUFTLElBQUlDLElBQUksR0FBR0MsS0FBSyxDQUFDO0lBQzlELE1BQU1DLE9BQU9QLEtBQUtRLFFBQVEsQ0FBQztJQUUzQixJQUFJQyxTQUFTQyxTQUFTUjtJQUN0QixJQUFJSyxRQUFRRSxXQUFXLElBQUlBLFVBQVU7SUFDckMsSUFBSSxDQUFDRixRQUFRRSxXQUFXLElBQUlBLFNBQVM7SUFFckMsTUFBTUUsWUFBWSxJQUFJQyxLQUFLYjtJQUMzQlksVUFBVUUsUUFBUSxDQUFDSixRQUFRQyxTQUFTUCxTQUFTLEdBQUc7SUFFaEQsTUFBTVcsVUFBVSxJQUFJRixLQUFLRDtJQUN6QkcsUUFBUUMsVUFBVSxDQUFDRCxRQUFRRSxVQUFVLEtBQUtmO0lBRTFDLE9BQU87UUFDTGdCLE9BQU9OLFVBQVVPLFdBQVc7UUFDNUJDLEtBQUtMLFFBQVFJLFdBQVc7SUFDMUI7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzaHJhZFxcT25lRHJpdmVcXERlc2t0b3BcXFByb2plY3RzXFxOZXh0anMtUmVhY3QtUG9ydGZvbGlvLVR1dG9yaWFsXFxteS1wb3J0Zm9saW9cXHNyY1xcbGliXFxnb29nbGVDYWxlbmRhci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBsaWIvZ29vZ2xlQ2FsZW5kYXIudHNcclxuXHJcbi8vIEV4dGVuZCBXaW5kb3cgaW50ZXJmYWNlIGZvciBHb29nbGUgQVBJXHJcbmRlY2xhcmUgZ2xvYmFsIHtcclxuICBpbnRlcmZhY2UgV2luZG93IHtcclxuICAgIGdhcGk6IGFueTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2FsZW5kYXJFdmVudCB7XHJcbiAgc3VtbWFyeTogc3RyaW5nO1xyXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XHJcbiAgc3RhcnQ6IHtcclxuICAgIGRhdGVUaW1lOiBzdHJpbmc7XHJcbiAgICB0aW1lWm9uZTogc3RyaW5nO1xyXG4gIH07XHJcbiAgZW5kOiB7XHJcbiAgICBkYXRlVGltZTogc3RyaW5nO1xyXG4gICAgdGltZVpvbmU6IHN0cmluZztcclxuICB9O1xyXG4gIGF0dGVuZGVlczogQXJyYXk8eyBlbWFpbDogc3RyaW5nIH0+O1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgR29vZ2xlQ2FsZW5kYXJBUEkge1xyXG4gIHByaXZhdGUgY2xpZW50SWQ6IHN0cmluZztcclxuICBwcml2YXRlIGdhcGk6IGFueTtcclxuICBwcml2YXRlIGlzSW5pdGlhbGl6ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmNsaWVudElkID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfR09PR0xFX0NMSUVOVF9JRCB8fCAnJztcclxuICB9XHJcblxyXG4gIGFzeW5jIGluaXRpYWxpemVHYXBpKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCkgcmV0dXJuIHRydWU7XHJcbiAgICBcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1dpbmRvdyBpcyBub3QgYXZhaWxhYmxlJykpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgaWYgZ2FwaSBpcyBhbHJlYWR5IGxvYWRlZFxyXG4gICAgICBpZiAod2luZG93LmdhcGkpIHtcclxuICAgICAgICB0aGlzLmxvYWRHYXBpQ2xpZW50KCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTG9hZCBnYXBpIHNjcmlwdFxyXG4gICAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcclxuICAgICAgc2NyaXB0LnNyYyA9ICdodHRwczovL2FwaXMuZ29vZ2xlLmNvbS9qcy9hcGkuanMnO1xyXG4gICAgICBzY3JpcHQub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMubG9hZEdhcGlDbGllbnQoKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgICByZXNvbHZlKHRydWUpO1xyXG4gICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgIH07XHJcbiAgICAgIHNjcmlwdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgR29vZ2xlIEFQSSBzY3JpcHQnKSk7XHJcbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBsb2FkR2FwaUNsaWVudCgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIHdpbmRvdy5nYXBpLmxvYWQoJ2NsaWVudDphdXRoMicsIHtcclxuICAgICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgd2luZG93LmdhcGkuY2xpZW50LmluaXQoe1xyXG4gICAgICAgICAgICAgIGNsaWVudElkOiB0aGlzLmNsaWVudElkLFxyXG4gICAgICAgICAgICAgIGRpc2NvdmVyeURvY3M6IFsnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vZGlzY292ZXJ5L3YxL2FwaXMvY2FsZW5kYXIvdjMvcmVzdCddLFxyXG4gICAgICAgICAgICAgIHNjb3BlOiAnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC9jYWxlbmRhci5ldmVudHMnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmdhcGkgPSB3aW5kb3cuZ2FwaTtcclxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uZXJyb3I6ICgpID0+IHJlamVjdChuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGdhcGkgY2xpZW50JykpXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBzaWduSW4oKTogUHJvbWlzZTxhbnk+IHtcclxuICAgIGlmICghdGhpcy5nYXBpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignR29vZ2xlIEFQSSBub3QgaW5pdGlhbGl6ZWQnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgYXV0aEluc3RhbmNlID0gdGhpcy5nYXBpLmF1dGgyLmdldEF1dGhJbnN0YW5jZSgpO1xyXG4gICAgaWYgKCFhdXRoSW5zdGFuY2UpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRoIGluc3RhbmNlIG5vdCBhdmFpbGFibGUnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIGF3YWl0IGF1dGhJbnN0YW5jZS5zaWduSW4oKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGNyZWF0ZUV2ZW50KGV2ZW50RGV0YWlsczogQ2FsZW5kYXJFdmVudCk6IFByb21pc2U8YW55PiB7XHJcbiAgICBpZiAoIXRoaXMuZ2FwaSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dvb2dsZSBBUEkgbm90IGluaXRpYWxpemVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdhcGkuY2xpZW50LmNhbGVuZGFyLmV2ZW50cy5pbnNlcnQoe1xyXG4gICAgICAgIGNhbGVuZGFySWQ6ICdwcmltYXJ5JyxcclxuICAgICAgICByZXNvdXJjZTogZXZlbnREZXRhaWxzXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UucmVzdWx0O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgY2FsZW5kYXIgZXZlbnQ6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlzU2lnbmVkSW4oKTogYm9vbGVhbiB7XHJcbiAgICBpZiAoIXRoaXMuZ2FwaSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgY29uc3QgYXV0aEluc3RhbmNlID0gdGhpcy5nYXBpLmF1dGgyLmdldEF1dGhJbnN0YW5jZSgpO1xyXG4gICAgcmV0dXJuIGF1dGhJbnN0YW5jZSAmJiBhdXRoSW5zdGFuY2UuaXNTaWduZWRJbi5nZXQoKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIFV0aWxpdHkgZnVuY3Rpb24gdG8gZm9ybWF0IGRhdGUvdGltZSBmb3IgR29vZ2xlIENhbGVuZGFyXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREYXRlVGltZShkYXRlOiBzdHJpbmcsIHRpbWU6IHN0cmluZywgZHVyYXRpb246IG51bWJlciA9IDMwKTogeyBzdGFydDogc3RyaW5nLCBlbmQ6IHN0cmluZyB9IHtcclxuICBjb25zdCBbaG91ciwgbWludXRlXSA9IHRpbWUucmVwbGFjZSgvW0FQXU0vLCAnJykudHJpbSgpLnNwbGl0KCc6Jyk7XHJcbiAgY29uc3QgaXNQTSA9IHRpbWUuaW5jbHVkZXMoJ1BNJyk7XHJcbiAgXHJcbiAgbGV0IGhvdXIyNCA9IHBhcnNlSW50KGhvdXIpO1xyXG4gIGlmIChpc1BNICYmIGhvdXIyNCAhPT0gMTIpIGhvdXIyNCArPSAxMjtcclxuICBpZiAoIWlzUE0gJiYgaG91cjI0ID09PSAxMikgaG91cjI0ID0gMDtcclxuXHJcbiAgY29uc3Qgc3RhcnREYXRlID0gbmV3IERhdGUoZGF0ZSk7XHJcbiAgc3RhcnREYXRlLnNldEhvdXJzKGhvdXIyNCwgcGFyc2VJbnQobWludXRlKSwgMCwgMCk7XHJcbiAgXHJcbiAgY29uc3QgZW5kRGF0ZSA9IG5ldyBEYXRlKHN0YXJ0RGF0ZSk7XHJcbiAgZW5kRGF0ZS5zZXRNaW51dGVzKGVuZERhdGUuZ2V0TWludXRlcygpICsgZHVyYXRpb24pO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgc3RhcnQ6IHN0YXJ0RGF0ZS50b0lTT1N0cmluZygpLFxyXG4gICAgZW5kOiBlbmREYXRlLnRvSVNPU3RyaW5nKClcclxuICB9O1xyXG59Il0sIm5hbWVzIjpbIkdvb2dsZUNhbGVuZGFyQVBJIiwiaW5pdGlhbGl6ZUdhcGkiLCJpc0luaXRpYWxpemVkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJFcnJvciIsIndpbmRvdyIsImdhcGkiLCJsb2FkR2FwaUNsaWVudCIsInRoZW4iLCJjYXRjaCIsInNjcmlwdCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInNyYyIsIm9ubG9hZCIsIm9uZXJyb3IiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJsb2FkIiwiY2FsbGJhY2siLCJjbGllbnQiLCJpbml0IiwiY2xpZW50SWQiLCJkaXNjb3ZlcnlEb2NzIiwic2NvcGUiLCJlcnJvciIsInNpZ25JbiIsImF1dGhJbnN0YW5jZSIsImF1dGgyIiwiZ2V0QXV0aEluc3RhbmNlIiwiY3JlYXRlRXZlbnQiLCJldmVudERldGFpbHMiLCJyZXNwb25zZSIsImNhbGVuZGFyIiwiZXZlbnRzIiwiaW5zZXJ0IiwiY2FsZW5kYXJJZCIsInJlc291cmNlIiwicmVzdWx0IiwiY29uc29sZSIsImlzU2lnbmVkSW4iLCJnZXQiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfR09PR0xFX0NMSUVOVF9JRCIsImZvcm1hdERhdGVUaW1lIiwiZGF0ZSIsInRpbWUiLCJkdXJhdGlvbiIsImhvdXIiLCJtaW51dGUiLCJyZXBsYWNlIiwidHJpbSIsInNwbGl0IiwiaXNQTSIsImluY2x1ZGVzIiwiaG91cjI0IiwicGFyc2VJbnQiLCJzdGFydERhdGUiLCJEYXRlIiwic2V0SG91cnMiLCJlbmREYXRlIiwic2V0TWludXRlcyIsImdldE1pbnV0ZXMiLCJzdGFydCIsInRvSVNPU3RyaW5nIiwiZW5kIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/googleCalendar.ts\n"));

/***/ })

});